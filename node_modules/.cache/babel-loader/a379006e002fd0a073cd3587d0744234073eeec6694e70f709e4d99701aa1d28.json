{"ast":null,"code":"/*\n * SoundTouch JS v0.1.30 audio processing library\n * Copyright (c) Olli Parviainen\n * Copyright (c) Ryan Berdeen\n * Copyright (c) Jakub Fiala\n * Copyright (c) Steve 'Cutter' Blades\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nclass FifoSampleBuffer {\n  constructor() {\n    this._vector = new Float32Array();\n    this._position = 0;\n    this._frameCount = 0;\n  }\n  get vector() {\n    return this._vector;\n  }\n  get position() {\n    return this._position;\n  }\n  get startIndex() {\n    return this._position * 2;\n  }\n  get frameCount() {\n    return this._frameCount;\n  }\n  get endIndex() {\n    return (this._position + this._frameCount) * 2;\n  }\n  clear() {\n    this.receive(this._frameCount);\n    this.rewind();\n  }\n  put(numFrames) {\n    this._frameCount += numFrames;\n  }\n  putSamples(samples, position) {\n    let numFrames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    position = position || 0;\n    const sourceOffset = position * 2;\n    if (!(numFrames >= 0)) {\n      numFrames = (samples.length - sourceOffset) / 2;\n    }\n    const numSamples = numFrames * 2;\n    this.ensureCapacity(numFrames + this._frameCount);\n    const destOffset = this.endIndex;\n    this.vector.set(samples.subarray(sourceOffset, sourceOffset + numSamples), destOffset);\n    this._frameCount += numFrames;\n  }\n  putBuffer(buffer, position) {\n    let numFrames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    position = position || 0;\n    if (!(numFrames >= 0)) {\n      numFrames = buffer.frameCount - position;\n    }\n    this.putSamples(buffer.vector, buffer.position + position, numFrames);\n  }\n  receive(numFrames) {\n    if (!(numFrames >= 0) || numFrames > this._frameCount) {\n      numFrames = this.frameCount;\n    }\n    this._frameCount -= numFrames;\n    this._position += numFrames;\n  }\n  receiveSamples(output) {\n    let numFrames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const numSamples = numFrames * 2;\n    const sourceOffset = this.startIndex;\n    output.set(this._vector.subarray(sourceOffset, sourceOffset + numSamples));\n    this.receive(numFrames);\n  }\n  extract(output) {\n    let position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let numFrames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const sourceOffset = this.startIndex + position * 2;\n    const numSamples = numFrames * 2;\n    output.set(this._vector.subarray(sourceOffset, sourceOffset + numSamples));\n  }\n  ensureCapacity() {\n    let numFrames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    const minLength = parseInt(numFrames * 2);\n    if (this._vector.length < minLength) {\n      const newVector = new Float32Array(minLength);\n      newVector.set(this._vector.subarray(this.startIndex, this.endIndex));\n      this._vector = newVector;\n      this._position = 0;\n    } else {\n      this.rewind();\n    }\n  }\n  ensureAdditionalCapacity() {\n    let numFrames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    this.ensureCapacity(this._frameCount + numFrames);\n  }\n  rewind() {\n    if (this._position > 0) {\n      this._vector.set(this._vector.subarray(this.startIndex, this.endIndex));\n      this._position = 0;\n    }\n  }\n}\nclass AbstractFifoSamplePipe {\n  constructor(createBuffers) {\n    if (createBuffers) {\n      this._inputBuffer = new FifoSampleBuffer();\n      this._outputBuffer = new FifoSampleBuffer();\n    } else {\n      this._inputBuffer = this._outputBuffer = null;\n    }\n  }\n  get inputBuffer() {\n    return this._inputBuffer;\n  }\n  set inputBuffer(inputBuffer) {\n    this._inputBuffer = inputBuffer;\n  }\n  get outputBuffer() {\n    return this._outputBuffer;\n  }\n  set outputBuffer(outputBuffer) {\n    this._outputBuffer = outputBuffer;\n  }\n  clear() {\n    this._inputBuffer.clear();\n    this._outputBuffer.clear();\n  }\n}\nclass RateTransposer extends AbstractFifoSamplePipe {\n  constructor(createBuffers) {\n    super(createBuffers);\n    this.reset();\n    this._rate = 1;\n  }\n  set rate(rate) {\n    this._rate = rate;\n  }\n  reset() {\n    this.slopeCount = 0;\n    this.prevSampleL = 0;\n    this.prevSampleR = 0;\n  }\n  clone() {\n    const result = new RateTransposer();\n    result.rate = this._rate;\n    return result;\n  }\n  process() {\n    const numFrames = this._inputBuffer.frameCount;\n    this._outputBuffer.ensureAdditionalCapacity(numFrames / this._rate + 1);\n    const numFramesOutput = this.transpose(numFrames);\n    this._inputBuffer.receive();\n    this._outputBuffer.put(numFramesOutput);\n  }\n  transpose() {\n    let numFrames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    if (numFrames === 0) {\n      return 0;\n    }\n    const src = this._inputBuffer.vector;\n    const srcOffset = this._inputBuffer.startIndex;\n    const dest = this._outputBuffer.vector;\n    const destOffset = this._outputBuffer.endIndex;\n    let used = 0;\n    let i = 0;\n    while (this.slopeCount < 1.0) {\n      dest[destOffset + 2 * i] = (1.0 - this.slopeCount) * this.prevSampleL + this.slopeCount * src[srcOffset];\n      dest[destOffset + 2 * i + 1] = (1.0 - this.slopeCount) * this.prevSampleR + this.slopeCount * src[srcOffset + 1];\n      i = i + 1;\n      this.slopeCount += this._rate;\n    }\n    this.slopeCount -= 1.0;\n    if (numFrames !== 1) {\n      out: while (true) {\n        while (this.slopeCount > 1.0) {\n          this.slopeCount -= 1.0;\n          used = used + 1;\n          if (used >= numFrames - 1) {\n            break out;\n          }\n        }\n        const srcIndex = srcOffset + 2 * used;\n        dest[destOffset + 2 * i] = (1.0 - this.slopeCount) * src[srcIndex] + this.slopeCount * src[srcIndex + 2];\n        dest[destOffset + 2 * i + 1] = (1.0 - this.slopeCount) * src[srcIndex + 1] + this.slopeCount * src[srcIndex + 3];\n        i = i + 1;\n        this.slopeCount += this._rate;\n      }\n    }\n    this.prevSampleL = src[srcOffset + 2 * numFrames - 2];\n    this.prevSampleR = src[srcOffset + 2 * numFrames - 1];\n    return i;\n  }\n}\nclass FilterSupport {\n  constructor(pipe) {\n    this._pipe = pipe;\n  }\n  get pipe() {\n    return this._pipe;\n  }\n  get inputBuffer() {\n    return this._pipe.inputBuffer;\n  }\n  get outputBuffer() {\n    return this._pipe.outputBuffer;\n  }\n  fillInputBuffer() {\n    throw new Error('fillInputBuffer() not overridden');\n  }\n  fillOutputBuffer() {\n    let numFrames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    while (this.outputBuffer.frameCount < numFrames) {\n      const numInputFrames = 8192 * 2 - this.inputBuffer.frameCount;\n      this.fillInputBuffer(numInputFrames);\n      if (this.inputBuffer.frameCount < 8192 * 2) {\n        break;\n      }\n      this._pipe.process();\n    }\n  }\n  clear() {\n    this._pipe.clear();\n  }\n}\nconst noop = function () {\n  return;\n};\nclass SimpleFilter extends FilterSupport {\n  constructor(sourceSound, pipe) {\n    let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n    super(pipe);\n    this.callback = callback;\n    this.sourceSound = sourceSound;\n    this.historyBufferSize = 22050;\n    this._sourcePosition = 0;\n    this.outputBufferPosition = 0;\n    this._position = 0;\n  }\n  get position() {\n    return this._position;\n  }\n  set position(position) {\n    if (position > this._position) {\n      throw new RangeError('New position may not be greater than current position');\n    }\n    const newOutputBufferPosition = this.outputBufferPosition - (this._position - position);\n    if (newOutputBufferPosition < 0) {\n      throw new RangeError('New position falls outside of history buffer');\n    }\n    this.outputBufferPosition = newOutputBufferPosition;\n    this._position = position;\n  }\n  get sourcePosition() {\n    return this._sourcePosition;\n  }\n  set sourcePosition(sourcePosition) {\n    this.clear();\n    this._sourcePosition = sourcePosition;\n  }\n  onEnd() {\n    this.callback();\n  }\n  fillInputBuffer() {\n    let numFrames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    const samples = new Float32Array(numFrames * 2);\n    const numFramesExtracted = this.sourceSound.extract(samples, numFrames, this._sourcePosition);\n    this._sourcePosition += numFramesExtracted;\n    this.inputBuffer.putSamples(samples, 0, numFramesExtracted);\n  }\n  extract(target) {\n    let numFrames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this.fillOutputBuffer(this.outputBufferPosition + numFrames);\n    const numFramesExtracted = Math.min(numFrames, this.outputBuffer.frameCount - this.outputBufferPosition);\n    this.outputBuffer.extract(target, this.outputBufferPosition, numFramesExtracted);\n    const currentFrames = this.outputBufferPosition + numFramesExtracted;\n    this.outputBufferPosition = Math.min(this.historyBufferSize, currentFrames);\n    this.outputBuffer.receive(Math.max(currentFrames - this.historyBufferSize, 0));\n    this._position += numFramesExtracted;\n    return numFramesExtracted;\n  }\n  handleSampleData(event) {\n    this.extract(event.data, 4096);\n  }\n  clear() {\n    super.clear();\n    this.outputBufferPosition = 0;\n  }\n}\nconst USE_AUTO_SEQUENCE_LEN = 0;\nconst DEFAULT_SEQUENCE_MS = USE_AUTO_SEQUENCE_LEN;\nconst USE_AUTO_SEEKWINDOW_LEN = 0;\nconst DEFAULT_SEEKWINDOW_MS = USE_AUTO_SEEKWINDOW_LEN;\nconst DEFAULT_OVERLAP_MS = 8;\nconst _SCAN_OFFSETS = [[124, 186, 248, 310, 372, 434, 496, 558, 620, 682, 744, 806, 868, 930, 992, 1054, 1116, 1178, 1240, 1302, 1364, 1426, 1488, 0], [-100, -75, -50, -25, 25, 50, 75, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [-20, -15, -10, -5, 5, 10, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [-4, -3, -2, -1, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]];\nconst AUTOSEQ_TEMPO_LOW = 0.5;\nconst AUTOSEQ_TEMPO_TOP = 2.0;\nconst AUTOSEQ_AT_MIN = 125.0;\nconst AUTOSEQ_AT_MAX = 50.0;\nconst AUTOSEQ_K = (AUTOSEQ_AT_MAX - AUTOSEQ_AT_MIN) / (AUTOSEQ_TEMPO_TOP - AUTOSEQ_TEMPO_LOW);\nconst AUTOSEQ_C = AUTOSEQ_AT_MIN - AUTOSEQ_K * AUTOSEQ_TEMPO_LOW;\nconst AUTOSEEK_AT_MIN = 25.0;\nconst AUTOSEEK_AT_MAX = 15.0;\nconst AUTOSEEK_K = (AUTOSEEK_AT_MAX - AUTOSEEK_AT_MIN) / (AUTOSEQ_TEMPO_TOP - AUTOSEQ_TEMPO_LOW);\nconst AUTOSEEK_C = AUTOSEEK_AT_MIN - AUTOSEEK_K * AUTOSEQ_TEMPO_LOW;\nclass Stretch extends AbstractFifoSamplePipe {\n  constructor(createBuffers) {\n    super(createBuffers);\n    this._quickSeek = true;\n    this.midBufferDirty = false;\n    this.midBuffer = null;\n    this.overlapLength = 0;\n    this.autoSeqSetting = true;\n    this.autoSeekSetting = true;\n    this._tempo = 1;\n    this.setParameters(44100, DEFAULT_SEQUENCE_MS, DEFAULT_SEEKWINDOW_MS, DEFAULT_OVERLAP_MS);\n  }\n  clear() {\n    super.clear();\n    this.clearMidBuffer();\n  }\n  clearMidBuffer() {\n    if (this.midBufferDirty) {\n      this.midBufferDirty = false;\n      this.midBuffer = null;\n    }\n  }\n  setParameters(sampleRate, sequenceMs, seekWindowMs, overlapMs) {\n    if (sampleRate > 0) {\n      this.sampleRate = sampleRate;\n    }\n    if (overlapMs > 0) {\n      this.overlapMs = overlapMs;\n    }\n    if (sequenceMs > 0) {\n      this.sequenceMs = sequenceMs;\n      this.autoSeqSetting = false;\n    } else {\n      this.autoSeqSetting = true;\n    }\n    if (seekWindowMs > 0) {\n      this.seekWindowMs = seekWindowMs;\n      this.autoSeekSetting = false;\n    } else {\n      this.autoSeekSetting = true;\n    }\n    this.calculateSequenceParameters();\n    this.calculateOverlapLength(this.overlapMs);\n    this.tempo = this._tempo;\n  }\n  set tempo(newTempo) {\n    let intskip;\n    this._tempo = newTempo;\n    this.calculateSequenceParameters();\n    this.nominalSkip = this._tempo * (this.seekWindowLength - this.overlapLength);\n    this.skipFract = 0;\n    intskip = Math.floor(this.nominalSkip + 0.5);\n    this.sampleReq = Math.max(intskip + this.overlapLength, this.seekWindowLength) + this.seekLength;\n  }\n  get tempo() {\n    return this._tempo;\n  }\n  get inputChunkSize() {\n    return this.sampleReq;\n  }\n  get outputChunkSize() {\n    return this.overlapLength + Math.max(0, this.seekWindowLength - 2 * this.overlapLength);\n  }\n  calculateOverlapLength() {\n    let overlapInMsec = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let newOvl;\n    newOvl = this.sampleRate * overlapInMsec / 1000;\n    newOvl = newOvl < 16 ? 16 : newOvl;\n    newOvl -= newOvl % 8;\n    this.overlapLength = newOvl;\n    this.refMidBuffer = new Float32Array(this.overlapLength * 2);\n    this.midBuffer = new Float32Array(this.overlapLength * 2);\n  }\n  checkLimits(x, mi, ma) {\n    return x < mi ? mi : x > ma ? ma : x;\n  }\n  calculateSequenceParameters() {\n    let seq;\n    let seek;\n    if (this.autoSeqSetting) {\n      seq = AUTOSEQ_C + AUTOSEQ_K * this._tempo;\n      seq = this.checkLimits(seq, AUTOSEQ_AT_MAX, AUTOSEQ_AT_MIN);\n      this.sequenceMs = Math.floor(seq + 0.5);\n    }\n    if (this.autoSeekSetting) {\n      seek = AUTOSEEK_C + AUTOSEEK_K * this._tempo;\n      seek = this.checkLimits(seek, AUTOSEEK_AT_MAX, AUTOSEEK_AT_MIN);\n      this.seekWindowMs = Math.floor(seek + 0.5);\n    }\n    this.seekWindowLength = Math.floor(this.sampleRate * this.sequenceMs / 1000);\n    this.seekLength = Math.floor(this.sampleRate * this.seekWindowMs / 1000);\n  }\n  set quickSeek(enable) {\n    this._quickSeek = enable;\n  }\n  clone() {\n    const result = new Stretch();\n    result.tempo = this._tempo;\n    result.setParameters(this.sampleRate, this.sequenceMs, this.seekWindowMs, this.overlapMs);\n    return result;\n  }\n  seekBestOverlapPosition() {\n    return this._quickSeek ? this.seekBestOverlapPositionStereoQuick() : this.seekBestOverlapPositionStereo();\n  }\n  seekBestOverlapPositionStereo() {\n    let bestOffset;\n    let bestCorrelation;\n    let correlation;\n    let i = 0;\n    this.preCalculateCorrelationReferenceStereo();\n    bestOffset = 0;\n    bestCorrelation = Number.MIN_VALUE;\n    for (; i < this.seekLength; i = i + 1) {\n      correlation = this.calculateCrossCorrelationStereo(2 * i, this.refMidBuffer);\n      if (correlation > bestCorrelation) {\n        bestCorrelation = correlation;\n        bestOffset = i;\n      }\n    }\n    return bestOffset;\n  }\n  seekBestOverlapPositionStereoQuick() {\n    let bestOffset;\n    let bestCorrelation;\n    let correlation;\n    let scanCount = 0;\n    let correlationOffset;\n    let tempOffset;\n    this.preCalculateCorrelationReferenceStereo();\n    bestCorrelation = Number.MIN_VALUE;\n    bestOffset = 0;\n    correlationOffset = 0;\n    tempOffset = 0;\n    for (; scanCount < 4; scanCount = scanCount + 1) {\n      let j = 0;\n      while (_SCAN_OFFSETS[scanCount][j]) {\n        tempOffset = correlationOffset + _SCAN_OFFSETS[scanCount][j];\n        if (tempOffset >= this.seekLength) {\n          break;\n        }\n        correlation = this.calculateCrossCorrelationStereo(2 * tempOffset, this.refMidBuffer);\n        if (correlation > bestCorrelation) {\n          bestCorrelation = correlation;\n          bestOffset = tempOffset;\n        }\n        j = j + 1;\n      }\n      correlationOffset = bestOffset;\n    }\n    return bestOffset;\n  }\n  preCalculateCorrelationReferenceStereo() {\n    let i = 0;\n    let context;\n    let temp;\n    for (; i < this.overlapLength; i = i + 1) {\n      temp = i * (this.overlapLength - i);\n      context = i * 2;\n      this.refMidBuffer[context] = this.midBuffer[context] * temp;\n      this.refMidBuffer[context + 1] = this.midBuffer[context + 1] * temp;\n    }\n  }\n  calculateCrossCorrelationStereo(mixingPosition, compare) {\n    const mixing = this._inputBuffer.vector;\n    mixingPosition += this._inputBuffer.startIndex;\n    let correlation = 0;\n    let i = 2;\n    const calcLength = 2 * this.overlapLength;\n    let mixingOffset;\n    for (; i < calcLength; i = i + 2) {\n      mixingOffset = i + mixingPosition;\n      correlation += mixing[mixingOffset] * compare[i] + mixing[mixingOffset + 1] * compare[i + 1];\n    }\n    return correlation;\n  }\n  overlap(overlapPosition) {\n    this.overlapStereo(2 * overlapPosition);\n  }\n  overlapStereo(inputPosition) {\n    const input = this._inputBuffer.vector;\n    inputPosition += this._inputBuffer.startIndex;\n    const output = this._outputBuffer.vector;\n    const outputPosition = this._outputBuffer.endIndex;\n    let i = 0;\n    let context;\n    let tempFrame;\n    const frameScale = 1 / this.overlapLength;\n    let fi;\n    let inputOffset;\n    let outputOffset;\n    for (; i < this.overlapLength; i = i + 1) {\n      tempFrame = (this.overlapLength - i) * frameScale;\n      fi = i * frameScale;\n      context = 2 * i;\n      inputOffset = context + inputPosition;\n      outputOffset = context + outputPosition;\n      output[outputOffset + 0] = input[inputOffset + 0] * fi + this.midBuffer[context + 0] * tempFrame;\n      output[outputOffset + 1] = input[inputOffset + 1] * fi + this.midBuffer[context + 1] * tempFrame;\n    }\n  }\n  process() {\n    let offset;\n    let temp;\n    let overlapSkip;\n    if (this.midBuffer === null) {\n      if (this._inputBuffer.frameCount < this.overlapLength) {\n        return;\n      }\n      this.midBuffer = new Float32Array(this.overlapLength * 2);\n      this._inputBuffer.receiveSamples(this.midBuffer, this.overlapLength);\n    }\n    while (this._inputBuffer.frameCount >= this.sampleReq) {\n      offset = this.seekBestOverlapPosition();\n      this._outputBuffer.ensureAdditionalCapacity(this.overlapLength);\n      this.overlap(Math.floor(offset));\n      this._outputBuffer.put(this.overlapLength);\n      temp = this.seekWindowLength - 2 * this.overlapLength;\n      if (temp > 0) {\n        this._outputBuffer.putBuffer(this._inputBuffer, offset + this.overlapLength, temp);\n      }\n      const start = this._inputBuffer.startIndex + 2 * (offset + this.seekWindowLength - this.overlapLength);\n      this.midBuffer.set(this._inputBuffer.vector.subarray(start, start + 2 * this.overlapLength));\n      this.skipFract += this.nominalSkip;\n      overlapSkip = Math.floor(this.skipFract);\n      this.skipFract -= overlapSkip;\n      this._inputBuffer.receive(overlapSkip);\n    }\n  }\n}\nconst testFloatEqual = function (a, b) {\n  return (a > b ? a - b : b - a) > 1e-10;\n};\nclass SoundTouch {\n  constructor() {\n    this.transposer = new RateTransposer(false);\n    this.stretch = new Stretch(false);\n    this._inputBuffer = new FifoSampleBuffer();\n    this._intermediateBuffer = new FifoSampleBuffer();\n    this._outputBuffer = new FifoSampleBuffer();\n    this._rate = 0;\n    this._tempo = 0;\n    this.virtualPitch = 1.0;\n    this.virtualRate = 1.0;\n    this.virtualTempo = 1.0;\n    this.calculateEffectiveRateAndTempo();\n  }\n  clear() {\n    this.transposer.clear();\n    this.stretch.clear();\n  }\n  clone() {\n    const result = new SoundTouch();\n    result.rate = this.rate;\n    result.tempo = this.tempo;\n    return result;\n  }\n  get rate() {\n    return this._rate;\n  }\n  set rate(rate) {\n    this.virtualRate = rate;\n    this.calculateEffectiveRateAndTempo();\n  }\n  set rateChange(rateChange) {\n    this._rate = 1.0 + 0.01 * rateChange;\n  }\n  get tempo() {\n    return this._tempo;\n  }\n  set tempo(tempo) {\n    this.virtualTempo = tempo;\n    this.calculateEffectiveRateAndTempo();\n  }\n  set tempoChange(tempoChange) {\n    this.tempo = 1.0 + 0.01 * tempoChange;\n  }\n  set pitch(pitch) {\n    this.virtualPitch = pitch;\n    this.calculateEffectiveRateAndTempo();\n  }\n  set pitchOctaves(pitchOctaves) {\n    this.pitch = Math.exp(0.69314718056 * pitchOctaves);\n    this.calculateEffectiveRateAndTempo();\n  }\n  set pitchSemitones(pitchSemitones) {\n    this.pitchOctaves = pitchSemitones / 12.0;\n  }\n  get inputBuffer() {\n    return this._inputBuffer;\n  }\n  get outputBuffer() {\n    return this._outputBuffer;\n  }\n  calculateEffectiveRateAndTempo() {\n    const previousTempo = this._tempo;\n    const previousRate = this._rate;\n    this._tempo = this.virtualTempo / this.virtualPitch;\n    this._rate = this.virtualRate * this.virtualPitch;\n    if (testFloatEqual(this._tempo, previousTempo)) {\n      this.stretch.tempo = this._tempo;\n    }\n    if (testFloatEqual(this._rate, previousRate)) {\n      this.transposer.rate = this._rate;\n    }\n    if (this._rate > 1.0) {\n      if (this._outputBuffer != this.transposer.outputBuffer) {\n        this.stretch.inputBuffer = this._inputBuffer;\n        this.stretch.outputBuffer = this._intermediateBuffer;\n        this.transposer.inputBuffer = this._intermediateBuffer;\n        this.transposer.outputBuffer = this._outputBuffer;\n      }\n    } else {\n      if (this._outputBuffer != this.stretch.outputBuffer) {\n        this.transposer.inputBuffer = this._inputBuffer;\n        this.transposer.outputBuffer = this._intermediateBuffer;\n        this.stretch.inputBuffer = this._intermediateBuffer;\n        this.stretch.outputBuffer = this._outputBuffer;\n      }\n    }\n  }\n  process() {\n    if (this._rate > 1.0) {\n      this.stretch.process();\n      this.transposer.process();\n    } else {\n      this.transposer.process();\n      this.stretch.process();\n    }\n  }\n}\nclass WebAudioBufferSource {\n  constructor(buffer) {\n    this.buffer = buffer;\n    this._position = 0;\n  }\n  get dualChannel() {\n    return this.buffer.numberOfChannels > 1;\n  }\n  get position() {\n    return this._position;\n  }\n  set position(value) {\n    this._position = value;\n  }\n  extract(target) {\n    let numFrames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let position = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    this.position = position;\n    let left = this.buffer.getChannelData(0);\n    let right = this.dualChannel ? this.buffer.getChannelData(1) : this.buffer.getChannelData(0);\n    let i = 0;\n    for (; i < numFrames; i++) {\n      target[i * 2] = left[i + position];\n      target[i * 2 + 1] = right[i + position];\n    }\n    return Math.min(numFrames, left.length - position);\n  }\n}\nconst getWebAudioNode = function (context, filter) {\n  let sourcePositionCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n  let bufferSize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 4096;\n  const node = context.createScriptProcessor(bufferSize, 2, 2);\n  const samples = new Float32Array(bufferSize * 2);\n  node.onaudioprocess = event => {\n    let left = event.outputBuffer.getChannelData(0);\n    let right = event.outputBuffer.getChannelData(1);\n    let framesExtracted = filter.extract(samples, bufferSize);\n    sourcePositionCallback(filter.sourcePosition);\n    if (framesExtracted === 0) {\n      filter.onEnd();\n    }\n    let i = 0;\n    for (; i < framesExtracted; i++) {\n      left[i] = samples[i * 2];\n      right[i] = samples[i * 2 + 1];\n    }\n  };\n  return node;\n};\nconst pad = function (n, width, z) {\n  z = z || '0';\n  n = n + '';\n  return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;\n};\nconst minsSecs = function (secs) {\n  const mins = Math.floor(secs / 60);\n  const seconds = secs - mins * 60;\n  return \"\".concat(mins, \":\").concat(pad(parseInt(seconds), 2));\n};\nconst onUpdate = function (sourcePosition) {\n  const currentTimePlayed = this.timePlayed;\n  const sampleRate = this.sampleRate;\n  this.sourcePosition = sourcePosition;\n  this.timePlayed = sourcePosition / sampleRate;\n  if (currentTimePlayed !== this.timePlayed) {\n    const timePlayed = new CustomEvent('play', {\n      detail: {\n        timePlayed: this.timePlayed,\n        formattedTimePlayed: this.formattedTimePlayed,\n        percentagePlayed: this.percentagePlayed\n      }\n    });\n    this._node.dispatchEvent(timePlayed);\n  }\n};\nclass PitchShifter {\n  constructor(context, buffer, bufferSize) {\n    let onEnd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;\n    this._soundtouch = new SoundTouch();\n    const source = new WebAudioBufferSource(buffer);\n    this.timePlayed = 0;\n    this.sourcePosition = 0;\n    this._filter = new SimpleFilter(source, this._soundtouch, onEnd);\n    this._node = getWebAudioNode(context, this._filter, sourcePostion => onUpdate.call(this, sourcePostion), bufferSize);\n    this.tempo = 1;\n    this.rate = 1;\n    this.duration = buffer.duration;\n    this.sampleRate = context.sampleRate;\n    this.listeners = [];\n  }\n  get formattedDuration() {\n    return minsSecs(this.duration);\n  }\n  get formattedTimePlayed() {\n    return minsSecs(this.timePlayed);\n  }\n  get percentagePlayed() {\n    return 100 * this._filter.sourcePosition / (this.duration * this.sampleRate);\n  }\n  set percentagePlayed(perc) {\n    this._filter.sourcePosition = parseInt(perc * this.duration * this.sampleRate);\n    this.sourcePosition = this._filter.sourcePosition;\n    this.timePlayed = this.sourcePosition / this.sampleRate;\n  }\n  get node() {\n    return this._node;\n  }\n  set pitch(pitch) {\n    this._soundtouch.pitch = pitch;\n  }\n  set pitchSemitones(semitone) {\n    this._soundtouch.pitchSemitones = semitone;\n  }\n  set rate(rate) {\n    this._soundtouch.rate = rate;\n  }\n  set tempo(tempo) {\n    this._soundtouch.tempo = tempo;\n  }\n  connect(toNode) {\n    this._node.connect(toNode);\n  }\n  disconnect() {\n    this._node.disconnect();\n  }\n  on(eventName, cb) {\n    this.listeners.push({\n      name: eventName,\n      cb: cb\n    });\n    this._node.addEventListener(eventName, event => cb(event.detail));\n  }\n  off() {\n    let eventName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let listeners = this.listeners;\n    if (eventName) {\n      listeners = listeners.filter(e => e.name === eventName);\n    }\n    listeners.forEach(e => {\n      this._node.removeEventListener(e.name, event => e.cb(event.detail));\n    });\n  }\n}\nexport { AbstractFifoSamplePipe, PitchShifter, RateTransposer, SimpleFilter, SoundTouch, Stretch, WebAudioBufferSource, getWebAudioNode };","map":{"version":3,"names":["FifoSampleBuffer","constructor","_vector","Float32Array","_position","_frameCount","vector","position","startIndex","frameCount","endIndex","clear","receive","rewind","put","numFrames","putSamples","samples","arguments","length","undefined","sourceOffset","numSamples","ensureCapacity","destOffset","set","subarray","putBuffer","buffer","receiveSamples","output","extract","minLength","parseInt","newVector","ensureAdditionalCapacity","AbstractFifoSamplePipe","createBuffers","_inputBuffer","_outputBuffer","inputBuffer","outputBuffer","RateTransposer","reset","_rate","rate","slopeCount","prevSampleL","prevSampleR","clone","result","process","numFramesOutput","transpose","src","srcOffset","dest","used","i","out","srcIndex","FilterSupport","pipe","_pipe","fillInputBuffer","Error","fillOutputBuffer","numInputFrames","noop","SimpleFilter","sourceSound","callback","historyBufferSize","_sourcePosition","outputBufferPosition","RangeError","newOutputBufferPosition","sourcePosition","onEnd","numFramesExtracted","target","Math","min","currentFrames","max","handleSampleData","event","data","USE_AUTO_SEQUENCE_LEN","DEFAULT_SEQUENCE_MS","USE_AUTO_SEEKWINDOW_LEN","DEFAULT_SEEKWINDOW_MS","DEFAULT_OVERLAP_MS","_SCAN_OFFSETS","AUTOSEQ_TEMPO_LOW","AUTOSEQ_TEMPO_TOP","AUTOSEQ_AT_MIN","AUTOSEQ_AT_MAX","AUTOSEQ_K","AUTOSEQ_C","AUTOSEEK_AT_MIN","AUTOSEEK_AT_MAX","AUTOSEEK_K","AUTOSEEK_C","Stretch","_quickSeek","midBufferDirty","midBuffer","overlapLength","autoSeqSetting","autoSeekSetting","_tempo","setParameters","clearMidBuffer","sampleRate","sequenceMs","seekWindowMs","overlapMs","calculateSequenceParameters","calculateOverlapLength","tempo","newTempo","intskip","nominalSkip","seekWindowLength","skipFract","floor","sampleReq","seekLength","inputChunkSize","outputChunkSize","overlapInMsec","newOvl","refMidBuffer","checkLimits","x","mi","ma","seq","seek","quickSeek","enable","seekBestOverlapPosition","seekBestOverlapPositionStereoQuick","seekBestOverlapPositionStereo","bestOffset","bestCorrelation","correlation","preCalculateCorrelationReferenceStereo","Number","MIN_VALUE","calculateCrossCorrelationStereo","scanCount","correlationOffset","tempOffset","j","context","temp","mixingPosition","compare","mixing","calcLength","mixingOffset","overlap","overlapPosition","overlapStereo","inputPosition","input","outputPosition","tempFrame","frameScale","fi","inputOffset","outputOffset","offset","overlapSkip","start","testFloatEqual","a","b","SoundTouch","transposer","stretch","_intermediateBuffer","virtualPitch","virtualRate","virtualTempo","calculateEffectiveRateAndTempo","rateChange","tempoChange","pitch","pitchOctaves","exp","pitchSemitones","previousTempo","previousRate","WebAudioBufferSource","dualChannel","numberOfChannels","value","left","getChannelData","right","getWebAudioNode","filter","sourcePositionCallback","bufferSize","node","createScriptProcessor","onaudioprocess","framesExtracted","pad","n","width","z","Array","join","minsSecs","secs","mins","seconds","concat","onUpdate","currentTimePlayed","timePlayed","CustomEvent","detail","formattedTimePlayed","percentagePlayed","_node","dispatchEvent","PitchShifter","_soundtouch","source","_filter","sourcePostion","call","duration","listeners","formattedDuration","perc","semitone","connect","toNode","disconnect","on","eventName","cb","push","name","addEventListener","off","e","forEach","removeEventListener"],"sources":["C:\\Users\\ozi38\\Downloads\\2syzgn\\node_modules\\soundtouchjs\\src\\FifoSampleBuffer.js","C:\\Users\\ozi38\\Downloads\\2syzgn\\node_modules\\soundtouchjs\\src\\AbstractFifoSamplePipe.js","C:\\Users\\ozi38\\Downloads\\2syzgn\\node_modules\\soundtouchjs\\src\\RateTransposer.js","C:\\Users\\ozi38\\Downloads\\2syzgn\\node_modules\\soundtouchjs\\src\\FilterSupport.js","C:\\Users\\ozi38\\Downloads\\2syzgn\\node_modules\\soundtouchjs\\src\\noop.js","C:\\Users\\ozi38\\Downloads\\2syzgn\\node_modules\\soundtouchjs\\src\\SimpleFilter.js","C:\\Users\\ozi38\\Downloads\\2syzgn\\node_modules\\soundtouchjs\\src\\Stretch.js","C:\\Users\\ozi38\\Downloads\\2syzgn\\node_modules\\soundtouchjs\\src\\testFloatEqual.js","C:\\Users\\ozi38\\Downloads\\2syzgn\\node_modules\\soundtouchjs\\src\\SoundTouch.js","C:\\Users\\ozi38\\Downloads\\2syzgn\\node_modules\\soundtouchjs\\src\\WebAudioBufferSource.js","C:\\Users\\ozi38\\Downloads\\2syzgn\\node_modules\\soundtouchjs\\src\\getWebAudioNode.js","C:\\Users\\ozi38\\Downloads\\2syzgn\\node_modules\\soundtouchjs\\src\\minsSecs.js","C:\\Users\\ozi38\\Downloads\\2syzgn\\node_modules\\soundtouchjs\\src\\PitchShifter.js"],"sourcesContent":["/*\n* SoundTouch JS audio processing library\n* Copyright (c) Olli Parviainen\n* Copyright (c) Ryan Berdeen\n* Copyright (c) Jakub Fiala\n* Copyright (c) Steve 'Cutter' Blades\n*\n* This library is free software; you can redistribute it and/or\n* modify it under the terms of the GNU Lesser General Public\n* License as published by the Free Software Foundation; either\n* version 2.1 of the License, or (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n* Lesser General Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this library; if not, write to the Free Software\n* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\nexport default class FifoSampleBuffer {\n  constructor() {\n    this._vector = new Float32Array();\n    this._position = 0;\n    this._frameCount = 0;\n  }\n\n  get vector() {\n    return this._vector;\n  }\n\n  get position() {\n    return this._position;\n  }\n\n  get startIndex() {\n    return this._position * 2;\n  }\n\n  get frameCount() {\n    return this._frameCount;\n  }\n\n  get endIndex() {\n    return (this._position + this._frameCount) * 2;\n  }\n\n  clear() {\n    this.receive(this._frameCount);\n    this.rewind();\n  }\n\n  put(numFrames) {\n    this._frameCount += numFrames;\n  }\n\n  putSamples(samples, position, numFrames = 0) {\n    position = position || 0;\n    const sourceOffset = position * 2;\n    if (!(numFrames >= 0)) {\n      numFrames = (samples.length - sourceOffset) / 2;\n    }\n    const numSamples = numFrames * 2;\n\n    this.ensureCapacity(numFrames + this._frameCount);\n\n    const destOffset = this.endIndex;\n    this.vector.set(\n      samples.subarray(sourceOffset, sourceOffset + numSamples),\n      destOffset\n    );\n\n    this._frameCount += numFrames;\n  }\n\n  putBuffer(buffer, position, numFrames = 0) {\n    position = position || 0;\n    if (!(numFrames >= 0)) {\n      numFrames = buffer.frameCount - position;\n    }\n    this.putSamples(buffer.vector, buffer.position + position, numFrames);\n  }\n\n  receive(numFrames) {\n    if (!(numFrames >= 0) || numFrames > this._frameCount) {\n      numFrames = this.frameCount;\n    }\n    this._frameCount -= numFrames;\n    this._position += numFrames;\n  }\n\n  receiveSamples(output, numFrames = 0) {\n    const numSamples = numFrames * 2;\n    const sourceOffset = this.startIndex;\n    output.set(this._vector.subarray(sourceOffset, sourceOffset + numSamples));\n    this.receive(numFrames);\n  }\n\n  extract(output, position = 0, numFrames = 0) {\n    const sourceOffset = this.startIndex + position * 2;\n    const numSamples = numFrames * 2;\n    output.set(this._vector.subarray(sourceOffset, sourceOffset + numSamples));\n  }\n\n  ensureCapacity(numFrames = 0) {\n    const minLength = parseInt(numFrames * 2);\n    if (this._vector.length < minLength) {\n      const newVector = new Float32Array(minLength);\n      newVector.set(this._vector.subarray(this.startIndex, this.endIndex));\n      this._vector = newVector;\n      this._position = 0;\n    } else {\n      this.rewind();\n    }\n  }\n\n  ensureAdditionalCapacity(numFrames = 0) {\n    this.ensureCapacity(this._frameCount + numFrames);\n  }\n\n  rewind() {\n    if (this._position > 0) {\n      this._vector.set(this._vector.subarray(this.startIndex, this.endIndex));\n      this._position = 0;\n    }\n  }\n}\n","/*\n* SoundTouch JS audio processing library\n* Copyright (c) Olli Parviainen\n* Copyright (c) Ryan Berdeen\n* Copyright (c) Jakub Fiala\n* Copyright (c) Steve 'Cutter' Blades\n*\n* This library is free software; you can redistribute it and/or\n* modify it under the terms of the GNU Lesser General Public\n* License as published by the Free Software Foundation; either\n* version 2.1 of the License, or (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n* Lesser General Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this library; if not, write to the Free Software\n* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\nimport FifoSampleBuffer from './FifoSampleBuffer';\n\nexport default class AbstractFifoSamplePipe {\n  constructor(createBuffers) {\n    if (createBuffers) {\n      this._inputBuffer = new FifoSampleBuffer();\n      this._outputBuffer = new FifoSampleBuffer();\n    } else {\n      this._inputBuffer = this._outputBuffer = null;\n    }\n  }\n\n  get inputBuffer() {\n    return this._inputBuffer;\n  }\n\n  set inputBuffer(inputBuffer) {\n    this._inputBuffer = inputBuffer;\n  }\n\n  get outputBuffer() {\n    return this._outputBuffer;\n  }\n\n  set outputBuffer(outputBuffer) {\n    this._outputBuffer = outputBuffer;\n  }\n\n  clear() {\n    this._inputBuffer.clear();\n    this._outputBuffer.clear();\n  }\n}\n","/*\n* SoundTouch JS audio processing library\n* Copyright (c) Olli Parviainen\n* Copyright (c) Ryan Berdeen\n* Copyright (c) Jakub Fiala\n* Copyright (c) Steve 'Cutter' Blades\n*\n* This library is free software; you can redistribute it and/or\n* modify it under the terms of the GNU Lesser General Public\n* License as published by the Free Software Foundation; either\n* version 2.1 of the License, or (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n* Lesser General Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this library; if not, write to the Free Software\n* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\nimport AbstractFifoSamplePipe from './AbstractFifoSamplePipe';\n\nexport default class RateTransposer extends AbstractFifoSamplePipe {\n  constructor(createBuffers) {\n    super(createBuffers);\n    this.reset();\n    this._rate = 1;\n  }\n\n  set rate(rate) {\n    this._rate = rate;\n    // TODO: aa filter\n  }\n\n  reset() {\n    this.slopeCount = 0;\n    this.prevSampleL = 0;\n    this.prevSampleR = 0;\n  }\n\n  clone() {\n    const result = new RateTransposer();\n    result.rate = this._rate;\n    return result;\n  }\n\n  process() {\n    // TODO: aa filter\n    const numFrames = this._inputBuffer.frameCount;\n    this._outputBuffer.ensureAdditionalCapacity(numFrames / this._rate + 1);\n    const numFramesOutput = this.transpose(numFrames);\n    this._inputBuffer.receive();\n    this._outputBuffer.put(numFramesOutput);\n  }\n\n  transpose(numFrames = 0) {\n    if (numFrames === 0) {\n      return 0;\n    }\n\n    const src = this._inputBuffer.vector;\n    const srcOffset = this._inputBuffer.startIndex;\n\n    const dest = this._outputBuffer.vector;\n    const destOffset = this._outputBuffer.endIndex;\n\n    let used = 0;\n    let i = 0;\n\n    while (this.slopeCount < 1.0) {\n      dest[destOffset + 2 * i] =\n        (1.0 - this.slopeCount) * this.prevSampleL +\n        this.slopeCount * src[srcOffset];\n      dest[destOffset + 2 * i + 1] =\n        (1.0 - this.slopeCount) * this.prevSampleR +\n        this.slopeCount * src[srcOffset + 1];\n      i = i + 1;\n      this.slopeCount += this._rate;\n    }\n\n    this.slopeCount -= 1.0;\n\n    if (numFrames !== 1) {\n      // eslint-disable-next-line no-constant-condition\n      out: while (true) {\n        while (this.slopeCount > 1.0) {\n          this.slopeCount -= 1.0;\n          used = used + 1;\n          if (used >= numFrames - 1) {\n            break out;\n          }\n        }\n\n        const srcIndex = srcOffset + 2 * used;\n        dest[destOffset + 2 * i] =\n          (1.0 - this.slopeCount) * src[srcIndex] +\n          this.slopeCount * src[srcIndex + 2];\n        dest[destOffset + 2 * i + 1] =\n          (1.0 - this.slopeCount) * src[srcIndex + 1] +\n          this.slopeCount * src[srcIndex + 3];\n\n        i = i + 1;\n        this.slopeCount += this._rate;\n      }\n    }\n\n    this.prevSampleL = src[srcOffset + 2 * numFrames - 2];\n    this.prevSampleR = src[srcOffset + 2 * numFrames - 1];\n\n    return i;\n  }\n}\n","/*\n* SoundTouch JS audio processing library\n* Copyright (c) Olli Parviainen\n* Copyright (c) Ryan Berdeen\n* Copyright (c) Jakub Fiala\n* Copyright (c) Steve 'Cutter' Blades\n*\n* This library is free software; you can redistribute it and/or\n* modify it under the terms of the GNU Lesser General Public\n* License as published by the Free Software Foundation; either\n* version 2.1 of the License, or (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n* Lesser General Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this library; if not, write to the Free Software\n* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\nexport default class FilterSupport {\n  constructor(pipe) {\n    this._pipe = pipe;\n  }\n\n  get pipe() {\n    return this._pipe;\n  }\n\n  get inputBuffer() {\n    return this._pipe.inputBuffer;\n  }\n\n  get outputBuffer() {\n    return this._pipe.outputBuffer;\n  }\n\n  fillInputBuffer(/*numFrames*/) {\n    throw new Error('fillInputBuffer() not overridden');\n  }\n\n  fillOutputBuffer(numFrames = 0) {\n    while (this.outputBuffer.frameCount < numFrames) {\n      // TODO hardcoded buffer size\n      const numInputFrames = 8192 * 2 - this.inputBuffer.frameCount;\n\n      this.fillInputBuffer(numInputFrames);\n\n      if (this.inputBuffer.frameCount < 8192 * 2) {\n        break;\n        // TODO: flush pipe\n      }\n      this._pipe.process();\n    }\n  }\n\n  clear() {\n    this._pipe.clear();\n  }\n}\n","const noop = function() {\n  return;\n};\n\nexport default noop;\n","/*\n * SoundTouch JS audio processing library\n * Copyright (c) Olli Parviainen\n * Copyright (c) Ryan Berdeen\n * Copyright (c) Jakub Fiala\n * Copyright (c) Steve 'Cutter' Blades\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nimport FilterSupport from './FilterSupport';\nimport noop from './noop';\n\nexport default class SimpleFilter extends FilterSupport {\n  constructor(sourceSound, pipe, callback = noop) {\n    super(pipe);\n    this.callback = callback;\n    this.sourceSound = sourceSound;\n    //this.bufferDuration = sourceSound.buffer.duration;\n    this.historyBufferSize = 22050;\n    this._sourcePosition = 0;\n    this.outputBufferPosition = 0;\n    this._position = 0;\n  }\n\n  get position() {\n    return this._position;\n  }\n\n  set position(position) {\n    if (position > this._position) {\n      throw new RangeError(\n        'New position may not be greater than current position'\n      );\n    }\n    const newOutputBufferPosition =\n      this.outputBufferPosition - (this._position - position);\n    if (newOutputBufferPosition < 0) {\n      throw new RangeError('New position falls outside of history buffer');\n    }\n    this.outputBufferPosition = newOutputBufferPosition;\n    this._position = position;\n  }\n\n  get sourcePosition() {\n    return this._sourcePosition;\n  }\n\n  set sourcePosition(sourcePosition) {\n    this.clear();\n    this._sourcePosition = sourcePosition;\n  }\n\n  onEnd() {\n    this.callback();\n  }\n\n  fillInputBuffer(numFrames = 0) {\n    const samples = new Float32Array(numFrames * 2);\n    const numFramesExtracted = this.sourceSound.extract(\n      samples,\n      numFrames,\n      this._sourcePosition\n    );\n    this._sourcePosition += numFramesExtracted;\n    this.inputBuffer.putSamples(samples, 0, numFramesExtracted);\n  }\n\n  extract(target, numFrames = 0) {\n    this.fillOutputBuffer(this.outputBufferPosition + numFrames);\n\n    const numFramesExtracted = Math.min(\n      numFrames,\n      this.outputBuffer.frameCount - this.outputBufferPosition\n    );\n    this.outputBuffer.extract(\n      target,\n      this.outputBufferPosition,\n      numFramesExtracted\n    );\n\n    const currentFrames = this.outputBufferPosition + numFramesExtracted;\n    this.outputBufferPosition = Math.min(this.historyBufferSize, currentFrames);\n    this.outputBuffer.receive(\n      Math.max(currentFrames - this.historyBufferSize, 0)\n    );\n\n    this._position += numFramesExtracted;\n    return numFramesExtracted;\n  }\n\n  handleSampleData(event) {\n    this.extract(event.data, 4096);\n  }\n\n  clear() {\n    super.clear();\n    this.outputBufferPosition = 0;\n  }\n}\n","/*\n * SoundTouch JS audio processing library\n * Copyright (c) Olli Parviainen\n * Copyright (c) Ryan Berdeen\n * Copyright (c) Jakub Fiala\n * Copyright (c) Steve 'Cutter' Blades\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nimport AbstractFifoSamplePipe from './AbstractFifoSamplePipe';\n\n/**\n * Giving this value for the sequence length sets automatic parameter value\n * according to tempo setting (recommended)\n */\nconst USE_AUTO_SEQUENCE_LEN = 0;\n\n/**\n * Default length of a single processing sequence, in milliseconds. This determines to how\n * long sequences the original sound is chopped in the time-stretch algorithm.\n *\n * The larger this value is, the lesser sequences are used in processing. In principle\n * a bigger value sounds better when slowing down tempo, but worse when increasing tempo\n * and vice versa.\n *\n * Increasing this value reduces computational burden and vice versa.\n */\n//const DEFAULT_SEQUENCE_MS = 130\nconst DEFAULT_SEQUENCE_MS = USE_AUTO_SEQUENCE_LEN;\n\n/**\n * Giving this value for the seek window length sets automatic parameter value\n * according to tempo setting (recommended)\n */\nconst USE_AUTO_SEEKWINDOW_LEN = 0;\n\n/**\n * Seeking window default length in milliseconds for algorithm that finds the best possible\n * overlapping location. This determines from how wide window the algorithm may look for an\n * optimal joining location when mixing the sound sequences back together.\n *\n * The bigger this window setting is, the higher the possibility to find a better mixing\n * position will become, but at the same time large values may cause a 'drifting' artifact\n * because consequent sequences will be taken at more uneven intervals.\n *\n * If there's a disturbing artifact that sounds as if a constant frequency was drifting\n * around, try reducing this setting.\n *\n * Increasing this value increases computational burden and vice versa.\n */\n//const DEFAULT_SEEKWINDOW_MS = 25;\nconst DEFAULT_SEEKWINDOW_MS = USE_AUTO_SEEKWINDOW_LEN;\n\n/**\n * Overlap length in milliseconds. When the chopped sound sequences are mixed back together,\n * to form a continuous sound stream, this parameter defines over how long period the two\n * consecutive sequences are let to overlap each other.\n *\n * This shouldn't be that critical parameter. If you reduce the DEFAULT_SEQUENCE_MS setting\n * by a large amount, you might wish to try a smaller value on this.\n *\n * Increasing this value increases computational burden and vice versa.\n */\nconst DEFAULT_OVERLAP_MS = 8;\n\n// Table for the hierarchical mixing position seeking algorithm\nconst _SCAN_OFFSETS = [\n  [\n    124, 186, 248, 310, 372, 434, 496, 558, 620, 682, 744, 806, 868, 930, 992,\n    1054, 1116, 1178, 1240, 1302, 1364, 1426, 1488, 0,\n  ],\n  [\n    -100, -75, -50, -25, 25, 50, 75, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0,\n  ],\n  [\n    -20, -15, -10, -5, 5, 10, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0,\n  ],\n  [-4, -3, -2, -1, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n];\n\n// Adjust tempo param according to tempo, so that variating processing sequence length is used\n// at varius tempo settings, between the given low...top limits\nconst AUTOSEQ_TEMPO_LOW = 0.5; // auto setting low tempo range (-50%)\nconst AUTOSEQ_TEMPO_TOP = 2.0; // auto setting top tempo range (+100%)\n\n// sequence-ms setting values at above low & top tempo\nconst AUTOSEQ_AT_MIN = 125.0;\nconst AUTOSEQ_AT_MAX = 50.0;\nconst AUTOSEQ_K =\n  (AUTOSEQ_AT_MAX - AUTOSEQ_AT_MIN) / (AUTOSEQ_TEMPO_TOP - AUTOSEQ_TEMPO_LOW);\nconst AUTOSEQ_C = AUTOSEQ_AT_MIN - AUTOSEQ_K * AUTOSEQ_TEMPO_LOW;\n\n// seek-window-ms setting values at above low & top tempo\nconst AUTOSEEK_AT_MIN = 25.0;\nconst AUTOSEEK_AT_MAX = 15.0;\nconst AUTOSEEK_K =\n  (AUTOSEEK_AT_MAX - AUTOSEEK_AT_MIN) / (AUTOSEQ_TEMPO_TOP - AUTOSEQ_TEMPO_LOW);\nconst AUTOSEEK_C = AUTOSEEK_AT_MIN - AUTOSEEK_K * AUTOSEQ_TEMPO_LOW;\n\nexport default class Stretch extends AbstractFifoSamplePipe {\n  constructor(createBuffers) {\n    super(createBuffers);\n    this._quickSeek = true;\n    this.midBufferDirty = false;\n\n    this.midBuffer = null;\n    this.overlapLength = 0;\n\n    this.autoSeqSetting = true;\n    this.autoSeekSetting = true;\n\n    this._tempo = 1;\n    this.setParameters(\n      44100,\n      DEFAULT_SEQUENCE_MS,\n      DEFAULT_SEEKWINDOW_MS,\n      DEFAULT_OVERLAP_MS\n    );\n  }\n\n  clear() {\n    super.clear();\n    this.clearMidBuffer();\n  }\n\n  clearMidBuffer() {\n    if (this.midBufferDirty) {\n      this.midBufferDirty = false;\n      this.midBuffer = null;\n    }\n  }\n\n  /**\n   * Sets routine control parameters. These control are certain time constants\n   * defining how the sound is stretched to the desired duration.\n   *\n   * 'sampleRate' = sample rate of the sound\n   * 'sequenceMS' = one processing sequence length in milliseconds (default = 82 ms)\n   * 'seekwindowMS' = seeking window length for scanning the best overlapping\n   *      position (default = 28 ms)\n   * 'overlapMS' = overlapping length (default = 12 ms)\n   */\n  setParameters(sampleRate, sequenceMs, seekWindowMs, overlapMs) {\n    // accept only positive parameter values - if zero or negative, use old values instead\n    if (sampleRate > 0) {\n      this.sampleRate = sampleRate;\n    }\n\n    if (overlapMs > 0) {\n      this.overlapMs = overlapMs;\n    }\n\n    if (sequenceMs > 0) {\n      this.sequenceMs = sequenceMs;\n      this.autoSeqSetting = false;\n    } else {\n      // zero or below, use automatic setting\n      this.autoSeqSetting = true;\n    }\n\n    if (seekWindowMs > 0) {\n      this.seekWindowMs = seekWindowMs;\n      this.autoSeekSetting = false;\n    } else {\n      // zero or below, use automatic setting\n      this.autoSeekSetting = true;\n    }\n\n    this.calculateSequenceParameters();\n\n    this.calculateOverlapLength(this.overlapMs);\n\n    // set tempo to recalculate 'sampleReq'\n    this.tempo = this._tempo;\n  }\n\n  /**\n   * Sets new target tempo. Normal tempo = 'SCALE', smaller values represent slower\n   * tempo, larger faster tempo.\n   */\n  set tempo(newTempo) {\n    let intskip;\n\n    this._tempo = newTempo;\n\n    // Calculate new sequence duration\n    this.calculateSequenceParameters();\n\n    // Calculate ideal skip length (according to tempo value)\n    this.nominalSkip =\n      this._tempo * (this.seekWindowLength - this.overlapLength);\n    this.skipFract = 0;\n    intskip = Math.floor(this.nominalSkip + 0.5);\n\n    // Calculate how many samples are needed in the 'inputBuffer' to process another batch of samples\n    this.sampleReq =\n      Math.max(intskip + this.overlapLength, this.seekWindowLength) +\n      this.seekLength;\n  }\n\n  get tempo() {\n    return this._tempo;\n  }\n\n  get inputChunkSize() {\n    return this.sampleReq;\n  }\n\n  get outputChunkSize() {\n    return (\n      this.overlapLength +\n      Math.max(0, this.seekWindowLength - 2 * this.overlapLength)\n    );\n  }\n\n  /**\n   * Calculates overlapInMsec period length in samples.\n   */\n  calculateOverlapLength(overlapInMsec = 0) {\n    let newOvl;\n\n    // TODO assert(overlapInMsec >= 0);\n    newOvl = (this.sampleRate * overlapInMsec) / 1000;\n    newOvl = newOvl < 16 ? 16 : newOvl;\n\n    // must be divisible by 8\n    newOvl -= newOvl % 8;\n\n    this.overlapLength = newOvl;\n\n    this.refMidBuffer = new Float32Array(this.overlapLength * 2);\n    this.midBuffer = new Float32Array(this.overlapLength * 2);\n  }\n\n  checkLimits(x, mi, ma) {\n    return x < mi ? mi : x > ma ? ma : x;\n  }\n\n  /**\n   * Calculates processing sequence length according to tempo setting\n   */\n  calculateSequenceParameters() {\n    let seq;\n    let seek;\n\n    if (this.autoSeqSetting) {\n      seq = AUTOSEQ_C + AUTOSEQ_K * this._tempo;\n      seq = this.checkLimits(seq, AUTOSEQ_AT_MAX, AUTOSEQ_AT_MIN);\n      this.sequenceMs = Math.floor(seq + 0.5);\n    }\n\n    if (this.autoSeekSetting) {\n      seek = AUTOSEEK_C + AUTOSEEK_K * this._tempo;\n      seek = this.checkLimits(seek, AUTOSEEK_AT_MAX, AUTOSEEK_AT_MIN);\n      this.seekWindowMs = Math.floor(seek + 0.5);\n    }\n\n    // Update seek window lengths\n    this.seekWindowLength = Math.floor(\n      (this.sampleRate * this.sequenceMs) / 1000\n    );\n    this.seekLength = Math.floor((this.sampleRate * this.seekWindowMs) / 1000);\n  }\n\n  /**\n   * Enables/disables the quick position seeking algorithm.\n   */\n  set quickSeek(enable) {\n    this._quickSeek = enable;\n  }\n\n  clone() {\n    const result = new Stretch();\n    result.tempo = this._tempo;\n    result.setParameters(\n      this.sampleRate,\n      this.sequenceMs,\n      this.seekWindowMs,\n      this.overlapMs\n    );\n    return result;\n  }\n\n  /**\n   * Seeks for the optimal overlap-mixing position.\n   */\n  seekBestOverlapPosition() {\n    return this._quickSeek\n      ? this.seekBestOverlapPositionStereoQuick()\n      : this.seekBestOverlapPositionStereo();\n  }\n\n  /**\n   * Seeks for the optimal overlap-mixing position. The 'stereo' version of the\n   * routine\n   *\n   * The best position is determined as the position where the two overlapped\n   * sample sequences are 'most alike', in terms of the highest cross-correlation\n   * value over the overlapping period\n   */\n  seekBestOverlapPositionStereo() {\n    let bestOffset;\n    let bestCorrelation;\n    let correlation;\n    let i = 0;\n\n    // Slopes the amplitudes of the 'midBuffer' samples\n    this.preCalculateCorrelationReferenceStereo();\n\n    bestOffset = 0;\n    bestCorrelation = Number.MIN_VALUE;\n\n    // Scans for the best correlation value by testing each possible position over the permitted range\n    for (; i < this.seekLength; i = i + 1) {\n      // Calculates correlation value for the mixing position corresponding to 'i'\n      correlation = this.calculateCrossCorrelationStereo(\n        2 * i,\n        this.refMidBuffer\n      );\n\n      // Checks for the highest correlation value\n      if (correlation > bestCorrelation) {\n        bestCorrelation = correlation;\n        bestOffset = i;\n      }\n    }\n\n    return bestOffset;\n  }\n\n  /**\n   * Seeks for the optimal overlap-mixing position. The 'stereo' version of the\n   * routine\n   *\n   * The best position is determined as the position where the two overlapped\n   * sample sequences are 'most alike', in terms of the highest cross-correlation\n   * value over the overlapping period\n   */\n  seekBestOverlapPositionStereoQuick() {\n    let bestOffset;\n    let bestCorrelation;\n    let correlation;\n    let scanCount = 0;\n    let correlationOffset;\n    let tempOffset;\n\n    // Slopes the amplitude of the 'midBuffer' samples\n    this.preCalculateCorrelationReferenceStereo();\n\n    bestCorrelation = Number.MIN_VALUE;\n    bestOffset = 0;\n    correlationOffset = 0;\n    tempOffset = 0;\n\n    // Scans for the best correlation value using four-pass hierarchical search.\n    //\n    // The look-up table 'scans' has hierarchical position adjusting steps.\n    // In first pass the routine searhes for the highest correlation with\n    // relatively coarse steps, then rescans the neighbourhood of the highest\n    // correlation with better resolution and so on.\n    for (; scanCount < 4; scanCount = scanCount + 1) {\n      let j = 0;\n      while (_SCAN_OFFSETS[scanCount][j]) {\n        tempOffset = correlationOffset + _SCAN_OFFSETS[scanCount][j];\n        if (tempOffset >= this.seekLength) {\n          break;\n        }\n\n        // Calculates correlation value for the mixing position corresponding to 'tempOffset'\n        correlation = this.calculateCrossCorrelationStereo(\n          2 * tempOffset,\n          this.refMidBuffer\n        );\n\n        // Checks for the highest correlation value\n        if (correlation > bestCorrelation) {\n          bestCorrelation = correlation;\n          bestOffset = tempOffset;\n        }\n        j = j + 1;\n      }\n      correlationOffset = bestOffset;\n    }\n\n    return bestOffset;\n  }\n\n  /**\n   * Slopes the amplitude of the 'midBuffer' samples so that cross correlation\n   * is faster to calculate\n   */\n  preCalculateCorrelationReferenceStereo() {\n    let i = 0;\n    let context;\n    let temp;\n\n    for (; i < this.overlapLength; i = i + 1) {\n      temp = i * (this.overlapLength - i);\n      context = i * 2;\n      this.refMidBuffer[context] = this.midBuffer[context] * temp;\n      this.refMidBuffer[context + 1] = this.midBuffer[context + 1] * temp;\n    }\n  }\n\n  calculateCrossCorrelationStereo(mixingPosition, compare) {\n    const mixing = this._inputBuffer.vector;\n    mixingPosition += this._inputBuffer.startIndex;\n\n    let correlation = 0;\n    let i = 2;\n    const calcLength = 2 * this.overlapLength;\n    let mixingOffset;\n\n    for (; i < calcLength; i = i + 2) {\n      mixingOffset = i + mixingPosition;\n      correlation +=\n        mixing[mixingOffset] * compare[i] +\n        mixing[mixingOffset + 1] * compare[i + 1];\n    }\n\n    return correlation;\n  }\n\n  // TODO inline\n  /**\n   * Overlaps samples in 'midBuffer' with the samples in 'pInputBuffer' at position\n   * of 'ovlPos'.\n   */\n  overlap(overlapPosition) {\n    this.overlapStereo(2 * overlapPosition);\n  }\n\n  /**\n   * Overlaps samples in 'midBuffer' with the samples in 'pInput'\n   */\n  overlapStereo(inputPosition) {\n    const input = this._inputBuffer.vector;\n    inputPosition += this._inputBuffer.startIndex;\n\n    const output = this._outputBuffer.vector;\n    const outputPosition = this._outputBuffer.endIndex;\n\n    let i = 0;\n    let context;\n    let tempFrame;\n    const frameScale = 1 / this.overlapLength;\n    let fi;\n    let inputOffset;\n    let outputOffset;\n\n    for (; i < this.overlapLength; i = i + 1) {\n      tempFrame = (this.overlapLength - i) * frameScale;\n      fi = i * frameScale;\n      context = 2 * i;\n      inputOffset = context + inputPosition;\n      outputOffset = context + outputPosition;\n      output[outputOffset + 0] =\n        input[inputOffset + 0] * fi + this.midBuffer[context + 0] * tempFrame;\n      output[outputOffset + 1] =\n        input[inputOffset + 1] * fi + this.midBuffer[context + 1] * tempFrame;\n    }\n  }\n\n  process() {\n    let offset;\n    let temp;\n    let overlapSkip;\n\n    if (this.midBuffer === null) {\n      // if midBuffer is empty, move the first samples of the input stream into it\n      if (this._inputBuffer.frameCount < this.overlapLength) {\n        // wait until we've got the overlapLength samples\n        return;\n      }\n      this.midBuffer = new Float32Array(this.overlapLength * 2);\n      this._inputBuffer.receiveSamples(this.midBuffer, this.overlapLength);\n    }\n\n    // Process samples as long as there are enough samples in 'inputBuffer' to form a processing frame\n    while (this._inputBuffer.frameCount >= this.sampleReq) {\n      // If tempo differs from the normal ('SCALE'), scan for hte best overlapping position\n      offset = this.seekBestOverlapPosition();\n\n      /**\n       * Mix the samples in the 'inputBuffer' at position of 'offset' with the samples in 'midBuffer'\n       * using sliding overlapping\n       * ... first partially overlap with the end of the previous sequence (that's in 'midBuffer')\n       */\n      this._outputBuffer.ensureAdditionalCapacity(this.overlapLength);\n      // FIXME unit?\n      // overlap(uint(offset));\n      this.overlap(Math.floor(offset));\n      this._outputBuffer.put(this.overlapLength);\n\n      // ... then copy sequence samples from 'inputBuffer' to output\n      temp = this.seekWindowLength - 2 * this.overlapLength; // & 0xfffffffe;\n      if (temp > 0) {\n        this._outputBuffer.putBuffer(\n          this._inputBuffer,\n          offset + this.overlapLength,\n          temp\n        );\n      }\n\n      /**\n       * Copies the end of the current sequence from 'inputBuffer' to 'midBuffer' for being mixed with\n       * the beginning of the next processing sequence and so on\n       */\n      // assert(offset + seekWindowLength <= (int)inputBuffer.numSamples());\n      const start =\n        this._inputBuffer.startIndex +\n        2 * (offset + this.seekWindowLength - this.overlapLength);\n      this.midBuffer.set(\n        this._inputBuffer.vector.subarray(start, start + 2 * this.overlapLength)\n      );\n\n      /**\n       * Remove the processed samples from the input buffer. Update the difference between\n       * integer & nominal skip step to 'skipFract' in order to prevent the error from\n       * accumulating over time\n       */\n      this.skipFract += this.nominalSkip; // real skip size\n      overlapSkip = Math.floor(this.skipFract);\n      this.skipFract -= overlapSkip;\n      this._inputBuffer.receive(overlapSkip);\n    }\n  }\n}\n","const testFloatEqual = function(a, b) {\n  return (a > b ? a - b : b - a) > 1e-10;\n};\n\nexport default testFloatEqual;\n","/*\n* SoundTouch JS audio processing library\n* Copyright (c) Olli Parviainen\n* Copyright (c) Ryan Berdeen\n* Copyright (c) Jakub Fiala\n* Copyright (c) Steve 'Cutter' Blades\n*\n* This library is free software; you can redistribute it and/or\n* modify it under the terms of the GNU Lesser General Public\n* License as published by the Free Software Foundation; either\n* version 2.1 of the License, or (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n* Lesser General Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this library; if not, write to the Free Software\n* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\nimport RateTransposer from './RateTransposer';\nimport Stretch from './Stretch';\nimport FifoSampleBuffer from './FifoSampleBuffer';\nimport testFloatEqual from './testFloatEqual';\n\nexport default class SoundTouch {\n  constructor() {\n    this.transposer = new RateTransposer(false);\n    this.stretch = new Stretch(false);\n\n    this._inputBuffer = new FifoSampleBuffer();\n    this._intermediateBuffer = new FifoSampleBuffer();\n    this._outputBuffer = new FifoSampleBuffer();\n\n    this._rate = 0;\n    this._tempo = 0;\n\n    this.virtualPitch = 1.0;\n    this.virtualRate = 1.0;\n    this.virtualTempo = 1.0;\n\n    this.calculateEffectiveRateAndTempo();\n  }\n\n  clear() {\n    this.transposer.clear();\n    this.stretch.clear();\n  }\n\n  clone() {\n    const result = new SoundTouch();\n    result.rate = this.rate;\n    result.tempo = this.tempo;\n    return result;\n  }\n\n  get rate() {\n    return this._rate;\n  }\n\n  set rate(rate) {\n    this.virtualRate = rate;\n    this.calculateEffectiveRateAndTempo();\n  }\n\n  set rateChange(rateChange) {\n    this._rate = 1.0 + 0.01 * rateChange;\n  }\n\n  get tempo() {\n    return this._tempo;\n  }\n\n  set tempo(tempo) {\n    this.virtualTempo = tempo;\n    this.calculateEffectiveRateAndTempo();\n  }\n\n  set tempoChange(tempoChange) {\n    this.tempo = 1.0 + 0.01 * tempoChange;\n  }\n\n  set pitch(pitch) {\n    this.virtualPitch = pitch;\n    this.calculateEffectiveRateAndTempo();\n  }\n\n  set pitchOctaves(pitchOctaves) {\n    this.pitch = Math.exp(0.69314718056 * pitchOctaves);\n    this.calculateEffectiveRateAndTempo();\n  }\n\n  set pitchSemitones(pitchSemitones) {\n    this.pitchOctaves = pitchSemitones / 12.0;\n  }\n\n  get inputBuffer() {\n    return this._inputBuffer;\n  }\n\n  get outputBuffer() {\n    return this._outputBuffer;\n  }\n\n  calculateEffectiveRateAndTempo() {\n    const previousTempo = this._tempo;\n    const previousRate = this._rate;\n\n    this._tempo = this.virtualTempo / this.virtualPitch;\n    this._rate = this.virtualRate * this.virtualPitch;\n\n    if (testFloatEqual(this._tempo, previousTempo)) {\n      this.stretch.tempo = this._tempo;\n    }\n    if (testFloatEqual(this._rate, previousRate)) {\n      this.transposer.rate = this._rate;\n    }\n\n    if (this._rate > 1.0) {\n      if (this._outputBuffer != this.transposer.outputBuffer) {\n        this.stretch.inputBuffer = this._inputBuffer;\n        this.stretch.outputBuffer = this._intermediateBuffer;\n\n        this.transposer.inputBuffer = this._intermediateBuffer;\n        this.transposer.outputBuffer = this._outputBuffer;\n      }\n    } else {\n      if (this._outputBuffer != this.stretch.outputBuffer) {\n        this.transposer.inputBuffer = this._inputBuffer;\n        this.transposer.outputBuffer = this._intermediateBuffer;\n\n        this.stretch.inputBuffer = this._intermediateBuffer;\n        this.stretch.outputBuffer = this._outputBuffer;\n      }\n    }\n  }\n\n  process() {\n    if (this._rate > 1.0) {\n      this.stretch.process();\n      this.transposer.process();\n    } else {\n      this.transposer.process();\n      this.stretch.process();\n    }\n  }\n}\n","/*\n* SoundTouch JS audio processing library\n* Copyright (c) Olli Parviainen\n* Copyright (c) Ryan Berdeen\n* Copyright (c) Jakub Fiala\n* Copyright (c) Steve 'Cutter' Blades\n*\n* This library is free software; you can redistribute it and/or\n* modify it under the terms of the GNU Lesser General Public\n* License as published by the Free Software Foundation; either\n* version 2.1 of the License, or (at your option) any later version.\n*\n* This library is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n* Lesser General Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this library; if not, write to the Free Software\n* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/\n\nexport default class WebAudioBufferSource {\n  constructor(buffer) {\n    this.buffer = buffer;\n    this._position = 0;\n  }\n\n  get dualChannel() {\n    return this.buffer.numberOfChannels > 1;\n  }\n\n  get position() {\n    return this._position;\n  }\n\n  set position(value) {\n    this._position = value;\n  }\n\n  extract(target, numFrames = 0, position = 0) {\n    this.position = position;\n    let left = this.buffer.getChannelData(0);\n    let right = this.dualChannel\n      ? this.buffer.getChannelData(1)\n      : this.buffer.getChannelData(0);\n    let i = 0;\n    for (; i < numFrames; i++) {\n      target[i * 2] = left[i + position];\n      target[i * 2 + 1] = right[i + position];\n    }\n    return Math.min(numFrames, left.length - position);\n  }\n}\n","import noop from './noop';\n/**\n * getWebAudioNode\n *\n * A wrapper to create an AudioNode and apply a filter for frame extraction\n * Copyright (c) Adrian Holovary https://github.com/adrianholovaty\n *\n * @param context - AudioContext\n * @param filter - Object containing an 'extract()' method\n * @param bufferSize - units of sample frames (256, 512, 1024, 2048, 4096, 8192, 16384)\n * @returns {ScriptProcessorNode}\n */\nconst getWebAudioNode = function(\n  context,\n  filter,\n  sourcePositionCallback = noop,\n  bufferSize = 4096\n) {\n  const node = context.createScriptProcessor(bufferSize, 2, 2);\n  const samples = new Float32Array(bufferSize * 2);\n\n  node.onaudioprocess = event => {\n    let left = event.outputBuffer.getChannelData(0);\n    let right = event.outputBuffer.getChannelData(1);\n    let framesExtracted = filter.extract(samples, bufferSize);\n    sourcePositionCallback(filter.sourcePosition);\n    if (framesExtracted === 0) {\n      filter.onEnd();\n    }\n    let i = 0;\n    for (; i < framesExtracted; i++) {\n      left[i] = samples[i * 2];\n      right[i] = samples[i * 2 + 1];\n    }\n  };\n  return node;\n};\n\nexport default getWebAudioNode;\n","const pad = function(n, width, z) {\n  z = z || '0';\n  n = n + '';\n  return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;\n};\n\nconst minsSecs = function(secs) {\n  const mins = Math.floor(secs / 60);\n  const seconds = secs - mins * 60;\n  return `${mins}:${pad(parseInt(seconds), 2)}`;\n};\n\nexport default minsSecs;\n","/*\n * SoundTouch JS audio processing library\n * Copyright (c) Olli Parviainen\n * Copyright (c) Ryan Berdeen\n * Copyright (c) Jakub Fiala\n * Copyright (c) Steve 'Cutter' Blades\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nimport WebAudioBufferSource from './WebAudioBufferSource';\nimport getWebAudioNode from './getWebAudioNode';\nimport SoundTouch from './SoundTouch';\nimport SimpleFilter from './SimpleFilter';\nimport minsSecs from './minsSecs';\nimport noop from './noop';\n\nconst onUpdate = function (sourcePosition) {\n  const currentTimePlayed = this.timePlayed;\n  const sampleRate = this.sampleRate;\n  this.sourcePosition = sourcePosition;\n  this.timePlayed = sourcePosition / sampleRate;\n  if (currentTimePlayed !== this.timePlayed) {\n    const timePlayed = new CustomEvent('play', {\n      detail: {\n        timePlayed: this.timePlayed,\n        formattedTimePlayed: this.formattedTimePlayed,\n        percentagePlayed: this.percentagePlayed,\n      },\n    });\n    this._node.dispatchEvent(timePlayed);\n  }\n};\n\nexport default class PitchShifter {\n  constructor(context, buffer, bufferSize, onEnd = noop) {\n    this._soundtouch = new SoundTouch();\n    const source = new WebAudioBufferSource(buffer);\n    this.timePlayed = 0;\n    this.sourcePosition = 0;\n    this._filter = new SimpleFilter(source, this._soundtouch, onEnd);\n    this._node = getWebAudioNode(\n      context,\n      this._filter,\n      (sourcePostion) => onUpdate.call(this, sourcePostion),\n      bufferSize\n    );\n    this.tempo = 1;\n    this.rate = 1;\n    this.duration = buffer.duration;\n    this.sampleRate = context.sampleRate;\n    this.listeners = [];\n  }\n\n  get formattedDuration() {\n    return minsSecs(this.duration);\n  }\n\n  get formattedTimePlayed() {\n    return minsSecs(this.timePlayed);\n  }\n\n  get percentagePlayed() {\n    return (\n      (100 * this._filter.sourcePosition) / (this.duration * this.sampleRate)\n    );\n  }\n\n  set percentagePlayed(perc) {\n    this._filter.sourcePosition = parseInt(\n      perc * this.duration * this.sampleRate\n    );\n    this.sourcePosition = this._filter.sourcePosition;\n    this.timePlayed = this.sourcePosition / this.sampleRate;\n  }\n\n  get node() {\n    return this._node;\n  }\n\n  set pitch(pitch) {\n    this._soundtouch.pitch = pitch;\n  }\n\n  set pitchSemitones(semitone) {\n    this._soundtouch.pitchSemitones = semitone;\n  }\n\n  set rate(rate) {\n    this._soundtouch.rate = rate;\n  }\n\n  set tempo(tempo) {\n    this._soundtouch.tempo = tempo;\n  }\n\n  connect(toNode) {\n    this._node.connect(toNode);\n  }\n\n  disconnect() {\n    this._node.disconnect();\n  }\n\n  on(eventName, cb) {\n    this.listeners.push({ name: eventName, cb: cb });\n    this._node.addEventListener(eventName, (event) => cb(event.detail));\n  }\n\n  off(eventName = null) {\n    let listeners = this.listeners;\n    if (eventName) {\n      listeners = listeners.filter((e) => e.name === eventName);\n    }\n    listeners.forEach((e) => {\n      this._node.removeEventListener(e.name, (event) => e.cb(event.detail));\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}